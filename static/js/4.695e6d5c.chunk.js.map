{"version":3,"sources":["../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js","algorithms/Ford–Fulkerson-Depth-First.ts","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js"],"names":["_taggedTemplateLiteral","strings","raw","slice","Object","freeze","defineProperties","value","FordFulkerson","name","linearDataStructure","pseudocode","sourceName","sinkName","String","references","label","url","labeledBlocks","lines","color","implementation","graph","sourceNode","getSourceNode","sinkNode","getSinkNode","flow","u","pred","mutationsToUndoAfterSearch","highlightedLines","linearNodes","length","getId","highlightedEdge","push","GraphEdgeHighlightMutation","inverse","graphMutations","cur","pop","GraphNodeHighlightMutation","getOutgoingEdges","edge","undefined","getTargetNode","isEqualTo","getCapacity","getFlow","f","currentHighlightEdge","foundPathHighlightMutations","mutationsToUndoAfterUpdate","reverse","map","mutation","df","Infinity","currentEdge","Math","min","reverseCurrentEdge","getReverseEdge","GraphEdgeFlowMutation","done","_createForOfIteratorHelper","o","Symbol","iterator","Array","isArray","i","F","s","n","e","_e","TypeError","it","err","normalCompletion","didErr","step","next","_e2"],"mappings":"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","file":"static/js/4.695e6d5c.chunk.js","sourcesContent":["export default function _taggedTemplateLiteral(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}","import {\n  Graph,\n  GraphMutation,\n  Node,\n  Edge,\n  GraphEdgeFlowMutation,\n  GraphNodeHighlightMutation,\n  GraphEdgeHighlightMutation\n} from \"../CytoscapeGraph\";\nimport { Algorithm } from \"../algorithm\";\n\n/** The Ford-Fulkerson algorithm using depth-first search */\nconst FordFulkerson: Algorithm = {\n  name: \"Ford–Fulkerson-Depth-First\",\n  linearDataStructure: \"stack\",\n  pseudocode: ({ sourceName, sinkName }) => String.raw`\n    \\begin{algorithm}\n    \\begin{algorithmic}\n    \\PROCEDURE{Ford-Fulkerson}{$G=(V,\\ E),\\ ${sourceName} \\in V,\\ ${sinkName} \\in V$}\n        \\STATE $f = 0$\n        \\REPEAT\n            \\STATE $p = \\left[\\ \\right]$\n            \\STATE $u = \\left[\\ ${sourceName}\\ \\right]$ \\COMMENT{create stack}\n            \\WHILE{$u_\\mathrm{height}$ > 0}\n                \\STATE $c =$ \\CALL{pop}{$u$}\n                \\FOR{edge $e$ originating from $c$}\n                    \\IF{$e_\\mathrm{target} \\notin p$ \\AND $e_\\mathrm{target} \\neq ${sourceName}$ \\AND $e_\\mathrm{capacity} > e_\\mathrm{flow}$}\n                        \\STATE $p[e_\\mathrm{target}] = e$\n                        \\STATE \\CALL{push}{$u$, $e_\\mathrm{target}$}\n                    \\ENDIF\n                \\ENDFOR\n            \\ENDWHILE\n            \\IF{$p[${sinkName}] \\neq \\varnothing$}\n                \\STATE $\\Delta f = \\infty$\n                \\FOR{$e \\in p$}\n                    \\STATE $\\Delta f = $ \\CALL{min}{$\\Delta f$, $e_\\mathrm{capacity} - e_\\mathrm{flow}$}\n                \\ENDFOR\n                \\FOR{$e \\in p$}\n                    \\STATE $r = e_\\mathrm{reverse}$\n                    \\STATE $e_\\mathrm{flow} = e_\\mathrm{flow} + \\Delta f$\n                    \\STATE $r_\\mathrm{flow} = r_\\mathrm{flow} - \\Delta f$\n                \\ENDFOR\n                \\STATE $f = f + \\Delta f$\n            \\ENDIF\n        \\UNTIL{$p[${sinkName}] = \\varnothing$}\n        \\RETURN $f$\n    \\ENDPROCEDURE\n    \\end{algorithmic}\n    \\end{algorithm}\n  `,\n  references: [\n    { label: `Ford-Fulkerson Algorithm at Brilliant.org`, url: 'https://brilliant.org/wiki/ford-fulkerson-algorithm/' },\n    { label: `L. R. Ford, D. R. Fulkerson: Maximal Flow Through a Network (1956)`, url: 'https://www.cambridge.org/core/services/aop-cambridge-core/content/view/5D6E55D3B06C4F7B1043BC1D82D40764/S0008414X00036890a.pdf/maximal_flow_through_a_network.pdf'}\n  ],\n  labeledBlocks: [\n    { lines: [4, 14], color: \"#ffdcdc\", label: \"Depth-first search\" },\n    {\n      lines: [15, 26],\n      color: \"#e3ffff\",\n      label: \"Increase flow along found path\"\n    }\n  ],\n  implementation: function*(\n    graph: Graph\n  ): IterableIterator<{\n    highlightedLines?: number[];\n    linearNodes: Node[];\n    graphMutations?: GraphMutation[];\n    done?: true;\n  }> {\n    const sourceNode = graph.getSourceNode();\n    const sinkNode = graph.getSinkNode();\n\n    let flow = 0;\n    let pred: { [key: string]: Edge };\n\n    do {\n      const u = [sourceNode];\n      pred = {};\n\n      const mutationsToUndoAfterSearch = [];\n\n      yield {\n        highlightedLines: [4, 5],\n        linearNodes: u\n      };\n\n      while (u.length > 0 && !pred[sinkNode.getId()]) {\n        const highlightedEdge = pred[u[u.length - 1].getId()];\n        if (highlightedEdge) {\n          mutationsToUndoAfterSearch.push(\n            new GraphEdgeHighlightMutation(highlightedEdge).inverse()\n          );\n          yield {\n            highlightedLines: [10, 11],\n            linearNodes: u,\n            graphMutations: [new GraphEdgeHighlightMutation(highlightedEdge)]\n          };\n        }\n\n        const cur = u.pop()!;\n        mutationsToUndoAfterSearch.push(\n          new GraphNodeHighlightMutation(cur).inverse()\n        );\n        yield {\n          highlightedLines: [7],\n          linearNodes: u,\n          graphMutations: [new GraphNodeHighlightMutation(cur)]\n        };\n        for (let edge of cur.getOutgoingEdges()) {\n          if (\n            pred[edge.getTargetNode().getId()] === undefined &&\n            !edge.getTargetNode().isEqualTo(sourceNode) &&\n            edge.getCapacity() > edge.getFlow()\n          ) {\n            pred[edge.getTargetNode().getId()] = edge;\n            u.push(edge.getTargetNode());\n          }\n          yield {\n            highlightedLines: [10, 11],\n            linearNodes: u\n          };\n          if (edge.getTargetNode().isEqualTo(sinkNode)) break;\n        }\n      }\n      if (pred[sinkNode.getId()] !== undefined) {\n        let currentHighlightEdge = pred[sinkNode.getId()];\n        const foundPathHighlightMutations: GraphMutation[] = [];\n        while (currentHighlightEdge) {\n          foundPathHighlightMutations.push(\n            new GraphEdgeHighlightMutation(currentHighlightEdge),\n            new GraphNodeHighlightMutation(\n              currentHighlightEdge.getSourceNode()\n            ),\n            new GraphNodeHighlightMutation(currentHighlightEdge.getTargetNode())\n          );\n          currentHighlightEdge =\n            pred[currentHighlightEdge.getSourceNode().getId()];\n        }\n        const mutationsToUndoAfterUpdate = foundPathHighlightMutations\n          .slice()\n          .reverse()\n          .map(mutation => mutation.inverse());\n\n        yield {\n          highlightedLines: [16],\n          linearNodes: u,\n          graphMutations: [\n            ...mutationsToUndoAfterSearch,\n            ...foundPathHighlightMutations\n          ]\n        };\n\n        let df = Infinity;\n        let currentEdge = pred[sinkNode.getId()];\n        while (currentEdge !== undefined) {\n          df = Math.min(df, currentEdge.getCapacity() - currentEdge.getFlow());\n          currentEdge = pred[currentEdge.getSourceNode().getId()];\n        }\n\n        currentEdge = pred[sinkNode.getId()];\n        while (currentEdge !== undefined) {\n          const reverseCurrentEdge = currentEdge.getReverseEdge();\n          yield {\n            highlightedLines: [22, 23],\n            linearNodes: u,\n            graphMutations: [\n              new GraphEdgeFlowMutation(currentEdge, df),\n              new GraphEdgeFlowMutation(reverseCurrentEdge, -df)\n            ]\n          };\n          currentEdge = pred[currentEdge.getSourceNode().getId()];\n        }\n        flow = flow + df;\n        yield {\n          highlightedLines: [25],\n          linearNodes: u,\n          graphMutations: mutationsToUndoAfterUpdate\n        };\n      }\n    } while (pred[sinkNode.getId()] !== undefined);\n    yield {\n      highlightedLines: [28],\n      linearNodes: [],\n      done: true\n    };\n    return flow;\n  }\n};\n\nexport default FordFulkerson;\n","import unsupportedIterableToArray from \"./unsupportedIterableToArray\";\nexport default function _createForOfIteratorHelper(o) {\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (o = unsupportedIterableToArray(o))) {\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var it,\n      normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}"],"sourceRoot":""}