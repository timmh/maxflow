{"version":3,"file":"static/js/443.ff37a290.chunk.js","mappings":"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","sources":["algorithms/Push-Relabel.ts","../node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","../node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js"],"sourcesContent":["import {\n  Graph,\n  GraphMutation,\n  Node,\n  Edge,\n  GraphEdgeFlowMutation,\n  GraphNodeHighlightMutation,\n  GraphEdgeHighlightMutation,\n  GraphNodeHeightMutation,\n  GraphNodeExcessMutation,\n  GraphCombinedMutation\n} from \"../CytoscapeGraph\";\nimport { Algorithm } from \"../algorithm\";\n\n/** The Push-Relabel algorithm */\nconst PushRelabel: Algorithm = {\n  name: \"Push-Relabel\",\n  linearDataStructure: \"none\",\n  pseudocode: ({ sourceName, sinkName }) => String.raw`\n    \\begin{algorithm}\n    \\begin{algorithmic}\n    \\PROCEDURE{Push-Relabel}{$G=(V,\\ E),\\ ${sourceName} \\in V,\\ ${sinkName} \\in V$}\n        \\FOR{vertex $v$}\n          \\STATE $v.h = 0$\n          \\STATE $v.e = 0$\n        \\ENDFOR\n\n        \\STATE $s.h = \\left|V\\right|$\n\n        \\FOR{vertex $v$ adjacent to $${sourceName}$}\n          \\STATE $(${sourceName}, v).f = (${sourceName}, v).c$\n          \\STATE $v.e = (${sourceName}, v).c$\n          \\STATE $${sourceName}.e = ${sourceName}.e - (${sourceName}, v).c$\n        \\ENDFOR\n\n        \\WHILE{there exists an applicable push or relabel operation}\n            \\STATE select an applicable push or relabel operation and perform it\n        \\ENDWHILE\n\n        \\RETURN $t.e$\n    \\ENDPROCEDURE\n    \\STATE\n    \\PROCEDURE{Push}{$u, v$}\n        \\STATE $\\Delta f = \\min(u.e, (u, v).c - (u, v).f)$\n        \\STATE $(u, v).f = (u, v).f + \\Delta f$\n        \\STATE $(v, u).f = (v, u).f - \\Delta f$\n        \\STATE $u.e = u.e - \\Delta f$\n        \\STATE $v.e = v.e + \\Delta f$\n    \\ENDPROCEDURE\n    \\STATE\n    \\PROCEDURE{Relabel}{$u$}\n        \\STATE $u.h = 1 + \\min\\{ v.h \\colon (u, v).c > (u, v).f \\}$\n    \\ENDPROCEDURE\n    \\end{algorithmic}\n    \\end{algorithm}\n  `,\n  references: [\n    {\n      label: `Push-Relabel Algorithm at geeksforgeeks.org`,\n      url:\n        \"https://www.geeksforgeeks.org/push-relabel-algorithm-set-1-introduction-and-illustration/\"\n    },\n    {\n      label: `Cormen, Leiserson, Rivest, Stein: Introduction to Algorithms (third edition, 2009)`,\n      url:\n        \"https://openlibrary.org/books/OL25409352M/Introduction_to_Algorithms\"\n    }\n  ],\n  labeledBlocks: [],\n  implementation: function*(\n    graph: Graph\n  ): IterableIterator<{\n    highlightedLines?: number[];\n    linearNodes: Node[];\n    graphMutations?: GraphMutation[];\n    done?: true;\n  }> {\n    const sourceNode = graph.getSourceNode();\n\n    yield {\n      linearNodes: [],\n      highlightedLines: [2, 3, 4, 5],\n      graphMutations: graph\n        .getNodes()\n        .map(\n          node =>\n            new GraphCombinedMutation([\n              new GraphNodeHeightMutation(node, 0),\n              new GraphNodeExcessMutation(node, 0)\n            ])\n        )\n    };\n\n    yield {\n      linearNodes: [],\n      highlightedLines: [6],\n      graphMutations: [\n        new GraphNodeHeightMutation(sourceNode, graph.getNodes().length),\n        new GraphNodeHighlightMutation(sourceNode)\n      ]\n    };\n\n    yield {\n      linearNodes: [],\n      highlightedLines: [7, 8, 9, 10, 11],\n      graphMutations: [\n        ...sourceNode\n          .getOutgoingEdges()\n          .map(\n            edge =>\n              new GraphCombinedMutation([\n                new GraphEdgeFlowMutation(edge, edge.getCapacity()),\n                new GraphNodeExcessMutation(\n                  edge.getTargetNode(),\n                  edge.getCapacity()\n                ),\n                new GraphNodeExcessMutation(sourceNode, -edge.getCapacity()),\n                new GraphEdgeHighlightMutation(edge)\n              ])\n          )\n      ]\n    };\n\n    let mutationToUndo = new GraphCombinedMutation([\n      new GraphNodeHighlightMutation(sourceNode),\n      ...sourceNode\n        .getOutgoingEdges()\n        .map(edge => new GraphEdgeHighlightMutation(edge))\n    ]);\n    let finished = false;\n    while (!finished) {\n      let foundApplicableOperation = false;\n      for (const edge of graph.getEdges()) {\n        if (pushApplicable(edge)) {\n          foundApplicableOperation = true;\n          yield {\n            linearNodes: [],\n            graphMutations: [mutationToUndo.inverse(), push(edge)],\n            highlightedLines: [13, 19, 20, 21, 22, 23]\n          };\n          mutationToUndo = push(edge);\n          break;\n        }\n      }\n      if (foundApplicableOperation) continue;\n      for (const node of graph.getNodes()) {\n        if (relabelApplicable(node)) {\n          foundApplicableOperation = true;\n          yield {\n            linearNodes: [],\n            graphMutations: [mutationToUndo.inverse(), relabel(node)],\n            highlightedLines: [13, 27]\n          };\n          mutationToUndo = relabel(node);\n          break;\n        }\n      }\n      finished = !foundApplicableOperation;\n    }\n\n    yield {\n      linearNodes: [],\n      graphMutations: [mutationToUndo.inverse()],\n      highlightedLines: [15],\n      done: true\n    };\n  }\n};\n\nconst min = (arr: number[]) =>\n  arr.reduce((min, val) => (min < val ? min : val), arr[0]);\n\nconst pushApplicable = (e: Edge) => {\n  const u = e.getSourceNode();\n  const v = e.getTargetNode();\n  return (\n    u.getType() !== \"sink\" &&\n    u.getExcess() > 0 &&\n    e.getCapacity() > e.getFlow() &&\n    u.getHeight() === v.getHeight() + 1\n  );\n};\n\nconst push = (e: Edge) => {\n  const u = e.getSourceNode();\n  const v = e.getTargetNode();\n  const df = Math.min(u.getExcess(), e.getCapacity() - e.getFlow());\n\n  return new GraphCombinedMutation([\n    new GraphEdgeFlowMutation(e, df),\n    new GraphEdgeHighlightMutation(e),\n    new GraphEdgeFlowMutation(e.getReverseEdge(), -df),\n    new GraphEdgeHighlightMutation(e.getReverseEdge()),\n    new GraphNodeExcessMutation(u, -df),\n    new GraphNodeHighlightMutation(u),\n    new GraphNodeExcessMutation(v, df),\n    new GraphNodeHighlightMutation(v)\n  ]);\n};\n\nconst relabelApplicable = (u: Node) =>\n  u.getExcess() > 0 &&\n  u\n    .getOutgoingEdges()\n    .filter(e => e.getCapacity() > e.getFlow())\n    .every(e => u.getHeight() <= e.getTargetNode().getHeight());\n\nconst relabel = (u: Node) =>\n  new GraphCombinedMutation([\n    new GraphNodeHeightMutation(\n      u,\n      1 +\n        min(\n          u\n            .getOutgoingEdges()\n            .filter(e => e.getCapacity() > e.getFlow())\n            .map(e => e.getTargetNode().getHeight())\n        ) -\n        u.getHeight()\n    ),\n    new GraphNodeHighlightMutation(u)\n  ]);\n\nexport default PushRelabel;\n","import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","export default function _taggedTemplateLiteral(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}"],"names":["PushRelabel","name","linearDataStructure","pseudocode","sourceName","sinkName","String","raw","references","label","url","labeledBlocks","implementation","graph","sourceNode","getSourceNode","linearNodes","highlightedLines","graphMutations","getNodes","map","node","GraphCombinedMutation","GraphNodeHeightMutation","GraphNodeExcessMutation","length","GraphNodeHighlightMutation","getOutgoingEdges","edge","GraphEdgeFlowMutation","getCapacity","getTargetNode","GraphEdgeHighlightMutation","mutationToUndo","finished","foundApplicableOperation","getEdges","pushApplicable","inverse","push","f","relabelApplicable","relabel","done","e","u","v","getType","getExcess","getFlow","getHeight","df","Math","min","getReverseEdge","filter","every","arr","reduce","val","_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","i","F","s","n","value","_e","TypeError","err","normalCompletion","didErr","call","step","next","_e2","_taggedTemplateLiteral","strings","slice","Object","freeze","defineProperties"],"sourceRoot":""}